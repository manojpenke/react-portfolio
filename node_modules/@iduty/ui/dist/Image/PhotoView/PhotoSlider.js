"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const variables_1 = require("./variables");
const isTouchDevice_1 = __importDefault(require("./utils/isTouchDevice"));
const limitTarget_1 = require("./utils/limitTarget");
const useIsomorphicLayoutEffect_1 = __importDefault(require("./hooks/useIsomorphicLayoutEffect"));
const useAdjacentImages_1 = __importDefault(require("./hooks/useAdjacentImages"));
const useSetState_1 = __importDefault(require("./hooks/useSetState"));
const useEventListener_1 = __importDefault(require("./hooks/useEventListener"));
const useAnimationVisible_1 = __importDefault(require("./hooks/useAnimationVisible"));
const useMethods_1 = __importDefault(require("./hooks/useMethods"));
const SlidePortal_1 = __importDefault(require("./components/SlidePortal"));
const CloseIcon_1 = __importDefault(require("./components/CloseIcon"));
const ArrowLeft_1 = __importDefault(require("./components/ArrowLeft"));
const ArrowRight_1 = __importDefault(require("./components/ArrowRight"));
const PreventScroll_1 = __importDefault(require("./components/PreventScroll"));
const PhotoBox_1 = __importDefault(require("./PhotoBox"));
require("./PhotoSlider.scss");
const initialState = {
    x: 0,
    touched: false,
    pause: false,
    lastCX: undefined,
    lastCY: undefined,
    bg: undefined,
    lastBg: undefined,
    overlay: true,
    minimal: true,
    scale: 1,
    rotate: 0,
};
function PhotoSlider(props) {
    const { loop = 3, speed: speedFn, easing: easingFn, photoClosable, maskClosable = true, maskOpacity = variables_1.defaultOpacity, pullClosable = true, bannerVisible = true, overlayRender, toolbarRender, className, maskClassName, photoClassName, photoWrapClassName, loadingElement, brokenElement, images, index: controlledIndex = 0, onIndexChange: controlledIndexChange, visible, onClose, afterClose, portalContainer = document.getElementById('app'), } = props;
    const [state, updateState] = (0, useSetState_1.default)(initialState);
    const [innerIndex, updateInnerIndex] = (0, react_1.useState)(0);
    const { x, touched, pause, lastCX, lastCY, bg = maskOpacity, lastBg, overlay, minimal, scale, rotate, onScale, onRotate, } = state;
    const isControlled = props.hasOwnProperty("index");
    const index = isControlled ? controlledIndex : innerIndex;
    const onIndexChange = isControlled ? controlledIndexChange : updateInnerIndex;
    const virtualIndexRef = (0, react_1.useRef)(index);
    const imageLength = images.length;
    const currentImage = images[index];
    const enableLoop = typeof loop === "boolean" ? loop : imageLength > loop;
    const [realVisible, activeAnimation, onAnimationEnd] = (0, useAnimationVisible_1.default)(visible, afterClose);
    (0, useIsomorphicLayoutEffect_1.default)(() => {
        if (realVisible) {
            updateState({
                pause: true,
                x: index * -(innerWidth + variables_1.horizontalOffset),
            });
            virtualIndexRef.current = index;
            return;
        }
        updateState(initialState);
    }, [realVisible]);
    const { close, changeIndex } = (0, useMethods_1.default)({
        close(evt) {
            if (onRotate) {
                onRotate(0);
            }
            updateState({
                overlay: true,
                lastBg: bg,
            });
            onClose(evt);
        },
        changeIndex(nextIndex, isPause = false) {
            const currentIndex = enableLoop ? virtualIndexRef.current + (nextIndex - index) : nextIndex;
            const max = imageLength - 1;
            const limitIndex = (0, limitTarget_1.limitNumber)(currentIndex, 0, max);
            const nextVirtualIndex = enableLoop ? currentIndex : limitIndex;
            const singlePageWidth = innerWidth + variables_1.horizontalOffset;
            updateState({
                touched: false,
                lastCX: undefined,
                lastCY: undefined,
                x: -singlePageWidth * nextVirtualIndex,
                pause: isPause,
            });
            virtualIndexRef.current = nextVirtualIndex;
            const realLoopIndex = nextIndex < 0 ? max : nextIndex > max ? 0 : nextIndex;
            if (onIndexChange) {
                onIndexChange(enableLoop ? realLoopIndex : limitIndex);
            }
        },
    });
    (0, useEventListener_1.default)("keydown", (evt) => {
        if (visible) {
            switch (evt.key) {
                case "ArrowLeft":
                    changeIndex(index - 1, true);
                    break;
                case "ArrowRight":
                    changeIndex(index + 1, true);
                    break;
                case "Escape":
                    close();
                    break;
                default:
            }
        }
    });
    function handlePhotoTap(closeable) {
        return closeable ? close() : updateState({ overlay: !overlay });
    }
    function handleResize() {
        updateState({
            x: -(innerWidth + variables_1.horizontalOffset) * index,
            lastCX: undefined,
            lastCY: undefined,
            pause: true,
        });
        virtualIndexRef.current = index;
    }
    function handleReachVerticalMove(clientY, nextScale) {
        if (lastCY === undefined) {
            updateState({
                touched: true,
                lastCY: clientY,
                bg,
                minimal: true,
            });
            return;
        }
        const opacity = maskOpacity === null ? null : (0, limitTarget_1.limitNumber)(maskOpacity, 0.01, maskOpacity - Math.abs(clientY - lastCY) / 100 / 4);
        updateState({
            touched: true,
            lastCY,
            bg: nextScale === 1 ? opacity : maskOpacity,
            minimal: nextScale === 1,
        });
    }
    function handleReachHorizontalMove(clientX) {
        if (lastCX === undefined) {
            updateState({
                touched: true,
                lastCX: clientX,
                x,
                pause: false,
            });
            return;
        }
        const originOffsetClientX = clientX - lastCX;
        let offsetClientX = originOffsetClientX;
        if (!enableLoop && ((index === 0 && originOffsetClientX > 0) || (index === imageLength - 1 && originOffsetClientX < 0))) {
            offsetClientX = originOffsetClientX / 2;
        }
        updateState({
            touched: true,
            lastCX,
            x: -(innerWidth + variables_1.horizontalOffset) * virtualIndexRef.current + offsetClientX,
            pause: false,
        });
    }
    function handleReachMove(reachPosition, clientX, clientY, nextScale) {
        if (reachPosition === "x") {
            handleReachHorizontalMove(clientX);
        }
        else if (reachPosition === "y") {
            handleReachVerticalMove(clientY, nextScale);
        }
    }
    function handleReachUp(clientX, clientY) {
        const offsetClientX = clientX - (lastCX !== null && lastCX !== void 0 ? lastCX : clientX);
        const offsetClientY = clientY - (lastCY !== null && lastCY !== void 0 ? lastCY : clientY);
        let willClose = false;
        if (offsetClientX < -variables_1.maxMoveOffset) {
            changeIndex(index + 1);
            return;
        }
        if (offsetClientX > variables_1.maxMoveOffset) {
            changeIndex(index - 1);
            return;
        }
        const singlePageWidth = innerWidth + variables_1.horizontalOffset;
        const currentTranslateX = -singlePageWidth * virtualIndexRef.current;
        if (Math.abs(offsetClientY) > 100 && minimal && pullClosable) {
            willClose = true;
            close();
        }
        updateState({
            touched: false,
            x: currentTranslateX,
            lastCX: undefined,
            lastCY: undefined,
            bg: maskOpacity,
            overlay: willClose ? true : overlay,
        });
    }
    const adjacentImages = (0, useAdjacentImages_1.default)(images, index, enableLoop);
    if (!realVisible) {
        return null;
    }
    const currentOverlayVisible = overlay && !activeAnimation;
    const currentOpacity = visible ? bg : lastBg;
    const overlayParams = onScale &&
        onRotate && {
        images,
        index,
        visible,
        onClose: close,
        onIndexChange: changeIndex,
        overlayVisible: currentOverlayVisible,
        overlay: currentImage && currentImage.overlay,
        scale,
        rotate,
        onScale,
        onRotate,
    };
    const currentSpeed = speedFn ? speedFn(activeAnimation) : variables_1.defaultSpeed;
    const currentEasing = easingFn ? easingFn(activeAnimation) : variables_1.defaultEasing;
    const slideSpeed = speedFn ? speedFn(3) : variables_1.defaultSpeed + 200;
    const slideEasing = easingFn ? easingFn(3) : variables_1.defaultEasing;
    return (react_1.default.createElement(SlidePortal_1.default, { className: `PhotoView-Portal${!currentOverlayVisible ? " PhotoView-Slider__clean" : ""}${!visible ? " PhotoView-Slider__willClose" : ""}${className ? ` ${className}` : ""}`, role: "dialog", onClick: (e) => e.stopPropagation(), container: portalContainer },
        visible && react_1.default.createElement(PreventScroll_1.default, null),
        react_1.default.createElement("div", { className: `PhotoView-Slider__Backdrop${maskClassName ? ` ${maskClassName}` : ""}${activeAnimation === 1 ? " PhotoView-Slider__fadeIn" : activeAnimation === 2 ? " PhotoView-Slider__fadeOut" : ""}`, style: {
                background: currentOpacity ? `rgba(0, 0, 0, ${currentOpacity})` : undefined,
                transitionTimingFunction: currentEasing,
                transitionDuration: `${touched ? 0 : currentSpeed}ms`,
                animationDuration: `${currentSpeed}ms`,
            }, onAnimationEnd: onAnimationEnd }),
        bannerVisible && (react_1.default.createElement("div", { className: "PhotoView-Slider__BannerWrap" },
            react_1.default.createElement("div", { className: "PhotoView-Slider__Counter" },
                index + 1,
                " / ",
                imageLength),
            react_1.default.createElement("div", { className: "PhotoView-Slider__BannerRight" },
                toolbarRender && overlayParams && toolbarRender(overlayParams),
                react_1.default.createElement(CloseIcon_1.default, { className: "PhotoView-Slider__toolbarIcon", onClick: close })))),
        adjacentImages.map((item, currentIndex) => {
            const nextIndex = !enableLoop && index === 0 ? index + currentIndex : virtualIndexRef.current - 1 + currentIndex;
            return (react_1.default.createElement(PhotoBox_1.default, { key: enableLoop ? `${item.key}/${item.src}/${nextIndex}` : item.key, item: item, speed: currentSpeed, easing: currentEasing, visible: visible, onReachMove: handleReachMove, onReachUp: handleReachUp, onPhotoTap: () => handlePhotoTap(photoClosable), onMaskTap: () => handlePhotoTap(maskClosable), wrapClassName: photoWrapClassName, className: photoClassName, style: {
                    left: `${(innerWidth + variables_1.horizontalOffset) * nextIndex}px`,
                    transform: `translate3d(${x}px, 0px, 0)`,
                    transition: touched || pause ? undefined : `transform ${slideSpeed}ms ${slideEasing}`,
                }, loadingElement: loadingElement, brokenElement: brokenElement, onPhotoResize: handleResize, isActive: virtualIndexRef.current === nextIndex, expose: updateState, container: portalContainer }));
        }),
        !isTouchDevice_1.default && bannerVisible && (react_1.default.createElement(react_1.default.Fragment, null,
            (enableLoop || index !== 0) && (react_1.default.createElement("div", { className: "PhotoView-Slider__ArrowLeft", onClick: () => changeIndex(index - 1, true) },
                react_1.default.createElement(ArrowLeft_1.default, null))),
            (enableLoop || index + 1 < imageLength) && (react_1.default.createElement("div", { className: "PhotoView-Slider__ArrowRight", onClick: () => changeIndex(index + 1, true) },
                react_1.default.createElement(ArrowRight_1.default, null))))),
        overlayRender && overlayParams && (react_1.default.createElement("div", { className: "PhotoView-Slider__Overlay" }, overlayRender(overlayParams)))));
}
exports.default = PhotoSlider;
