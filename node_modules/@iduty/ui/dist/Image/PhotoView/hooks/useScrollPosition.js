"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const edgeHandle_1 = require("../utils/edgeHandle");
const getPositionOnMoveOrScale_1 = __importDefault(require("../utils/getPositionOnMoveOrScale"));
const getRotateSize_1 = __importDefault(require("../utils/getRotateSize"));
const variables_1 = require("../variables");
const useMethods_1 = __importDefault(require("./useMethods"));
const rebound = (start, bound, callback) => easeOutMove(start, bound, callback, variables_1.defaultSpeed / 4, (t) => t, () => easeOutMove(bound, start, callback));
function useScrollPosition(callbackX, callbackY, callbackS, container) {
    const innerHeight = container.getBoundingClientRect().height;
    const callback = (0, useMethods_1.default)({
        X: (spatial) => callbackX(spatial),
        Y: (spatial) => callbackY(spatial),
        S: (spatial) => callbackS(spatial),
    });
    return (x, y, lastX, lastY, width, height, scale, safeScale, lastScale, rotate, touchedTime) => {
        const [currentWidth, currentHeight] = (0, getRotateSize_1.default)(rotate, width, height);
        const [beginEdgeX, beginX] = (0, edgeHandle_1.computePositionEdge)(x, safeScale, currentWidth, innerWidth);
        const [beginEdgeY, beginY] = (0, edgeHandle_1.computePositionEdge)(y, safeScale, currentHeight, innerHeight);
        const moveTime = Date.now() - touchedTime;
        if (moveTime >= variables_1.maxTouchTime || safeScale !== scale || Math.abs(lastScale - scale) > 1) {
            const clientX = innerWidth / 2;
            const clientY = innerHeight / 2;
            const { x: nextX, y: nextY } = (0, getPositionOnMoveOrScale_1.default)(x, y, width, height, scale, safeScale, clientX, clientY, container);
            const targetX = beginEdgeX ? beginX : nextX !== x ? nextX : null;
            const targetY = beginEdgeY ? beginY : nextY !== y ? nextY : null;
            if (targetX !== null) {
                easeOutMove(x, targetX, callback.X);
            }
            if (targetY !== null) {
                easeOutMove(y, targetY, callback.Y);
            }
            if (safeScale !== scale) {
                easeOutMove(scale, safeScale, callback.S);
            }
            return;
        }
        const speedX = (x - lastX) / moveTime;
        const speedY = (y - lastY) / moveTime;
        const speedT = Math.sqrt(Math.pow(speedX, 2) + Math.pow(speedY, 2));
        let edgeX = false;
        let edgeY = false;
        scrollMove(speedT, (spatial) => {
            const nextX = x + spatial * (speedX / speedT);
            const nextY = y + spatial * (speedY / speedT);
            const [isEdgeX, currentX] = (0, edgeHandle_1.computePositionEdge)(nextX, scale, currentWidth, innerWidth);
            const [isEdgeY, currentY] = (0, edgeHandle_1.computePositionEdge)(nextY, scale, currentHeight, innerHeight);
            if (isEdgeX && !edgeX) {
                edgeX = true;
                if (beginEdgeX) {
                    easeOutMove(nextX, currentX, callback.X);
                }
                else {
                    rebound(currentX, nextX + (nextX - currentX), callback.X);
                }
            }
            if (isEdgeY && !edgeY) {
                edgeY = true;
                if (beginEdgeY) {
                    easeOutMove(nextY, currentY, callback.Y);
                }
                else {
                    rebound(currentY, nextY + (nextY - currentY), callback.Y);
                }
            }
            if (edgeX && edgeY) {
                return false;
            }
            const resultX = edgeX || callback.X(currentX);
            const resultY = edgeY || callback.Y(currentY);
            return resultX && resultY;
        });
    };
}
exports.default = useScrollPosition;
const acceleration = -0.001;
const resistance = 0.0002;
function scrollMove(initialSpeed, callback) {
    let v = initialSpeed;
    let s = 0;
    let lastTime;
    let frameId = 0;
    const calcMove = (now) => {
        if (!lastTime) {
            lastTime = now;
        }
        const dt = now - lastTime;
        const direction = Math.sign(initialSpeed);
        const a = direction * acceleration;
        const f = Math.sign(-v) * Math.pow(v, 2) * resistance;
        const ds = v * dt + ((a + f) * Math.pow(dt, 2)) / 2;
        v += (a + f) * dt;
        s += ds;
        lastTime = now;
        if (direction * v <= 0) {
            caf();
            return;
        }
        if (callback(s)) {
            raf();
            return;
        }
        caf();
    };
    raf();
    function raf() {
        frameId = requestAnimationFrame(calcMove);
    }
    function caf() {
        cancelAnimationFrame(frameId);
    }
}
const easeOutQuart = (x) => 1 - Math.pow((1 - x), 4);
function easeOutMove(start, end, callback, speed = variables_1.defaultSpeed, easing = easeOutQuart, complete) {
    const distance = end - start;
    if (distance === 0) {
        return;
    }
    const startTime = Date.now();
    let frameId = 0;
    const calcMove = () => {
        const time = Math.min(1, (Date.now() - startTime) / speed);
        const result = callback(start + easing(time) * distance);
        if (result && time < 1) {
            raf();
            return;
        }
        cancelAnimationFrame(frameId);
        if (time >= 1 && complete) {
            complete();
        }
    };
    raf();
    function raf() {
        frameId = requestAnimationFrame(calcMove);
    }
}
