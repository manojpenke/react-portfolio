"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const isTouchDevice_1 = __importDefault(require("./utils/isTouchDevice"));
const getMultipleTouchPosition_1 = __importDefault(require("./utils/getMultipleTouchPosition"));
const getPositionOnMoveOrScale_1 = __importDefault(require("./utils/getPositionOnMoveOrScale"));
const edgeHandle_1 = require("./utils/edgeHandle");
const getRotateSize_1 = __importDefault(require("./utils/getRotateSize"));
const limitTarget_1 = require("./utils/limitTarget");
const getSuitableImageSize_1 = __importDefault(require("./utils/getSuitableImageSize"));
const useIsomorphicLayoutEffect_1 = __importDefault(require("./hooks/useIsomorphicLayoutEffect"));
const variables_1 = require("./variables");
const useSetState_1 = __importDefault(require("./hooks/useSetState"));
const useMethods_1 = __importDefault(require("./hooks/useMethods"));
const useDebounceCallback_1 = __importDefault(require("./hooks/useDebounceCallback"));
const useEventListener_1 = __importDefault(require("./hooks/useEventListener"));
const useContinuousTap_1 = __importDefault(require("./hooks/useContinuousTap"));
const useScrollPosition_1 = __importDefault(require("./hooks/useScrollPosition"));
const useAnimationPosition_1 = __importDefault(require("./hooks/useAnimationPosition"));
const useMountedRef_1 = __importDefault(require("./hooks/useMountedRef"));
const Photo_1 = __importDefault(require("./Photo"));
require("./PhotoBox.scss");
const initialState = {
    naturalWidth: undefined,
    naturalHeight: undefined,
    width: undefined,
    height: undefined,
    loaded: undefined,
    broken: false,
    x: 0,
    y: 0,
    touched: false,
    maskTouched: false,
    rotate: 0,
    scale: 1,
    CX: 0,
    CY: 0,
    lastX: 0,
    lastY: 0,
    lastCX: 0,
    lastCY: 0,
    lastScale: 1,
    touchTime: 0,
    touchLength: 0,
    pause: true,
    stopRaf: true,
    reach: undefined,
};
function PhotoBox({ item: { src, render, width: customWidth = 0, height: customHeight = 0, originRef, }, visible, speed, easing, wrapClassName, className, style, loadingElement, brokenElement, onPhotoTap, onMaskTap, onReachMove, onReachUp, onPhotoResize, isActive, expose, container }) {
    const [state, updateState] = (0, useSetState_1.default)(initialState);
    const initialTouchRef = (0, react_1.useRef)(0);
    const mounted = (0, useMountedRef_1.default)();
    const { naturalWidth = customWidth, naturalHeight = customHeight, width = customWidth, height = customHeight, loaded = !src, broken, x, y, touched, stopRaf, maskTouched, rotate, scale, CX, CY, lastX, lastY, lastCX, lastCY, lastScale, touchTime, touchLength, pause, reach, } = state;
    const fn = (0, useMethods_1.default)({
        onScale: (current) => onScale((0, limitTarget_1.limitScale)(current)),
        onRotate(current) {
            if (rotate !== current) {
                expose({ rotate: current });
                updateState(Object.assign({ rotate: current }, (0, getSuitableImageSize_1.default)(naturalWidth, naturalHeight, current, container)));
            }
        },
    });
    function onScale(current, clientX, clientY) {
        if (scale !== current) {
            expose({ scale: current });
            updateState(Object.assign(Object.assign({ scale: current }, (0, getPositionOnMoveOrScale_1.default)(x, y, width, height, scale, current, clientX, clientY, container)), (current <= 1 && { x: 0, y: 0 })));
        }
    }
    const handleMove = (0, useDebounceCallback_1.default)((nextClientX, nextClientY, currentTouchLength = 0) => {
        var _a, _b;
        if ((touched || maskTouched) && isActive) {
            const [currentWidth, currentHeight] = (0, getRotateSize_1.default)(rotate, width, height);
            if (currentTouchLength === 0 && initialTouchRef.current === 0) {
                const isStillX = Math.abs(nextClientX - CX) <= variables_1.minStartTouchOffset;
                const isStillY = Math.abs(nextClientY - CY) <= variables_1.minStartTouchOffset;
                if (isStillX && isStillY) {
                    updateState({
                        lastCX: nextClientX,
                        lastCY: nextClientY,
                    });
                    return;
                }
                initialTouchRef.current = !isStillX ? 1 : nextClientY > CY ? 3 : 2;
            }
            const offsetX = nextClientX - lastCX;
            const offsetY = nextClientY - lastCY;
            let currentReach;
            if (currentTouchLength === 0) {
                const [horizontalCloseEdge] = (0, edgeHandle_1.computePositionEdge)(offsetX + lastX, scale, currentWidth, innerWidth);
                const innerHeight = (_b = (_a = container === null || container === void 0 ? void 0 : container.getBoundingClientRect) === null || _a === void 0 ? void 0 : _a.call(container)) === null || _b === void 0 ? void 0 : _b.height;
                const [verticalCloseEdge] = (0, edgeHandle_1.computePositionEdge)(offsetY + lastY, scale, currentHeight, innerHeight);
                currentReach = (0, edgeHandle_1.getReachType)(initialTouchRef.current, horizontalCloseEdge, verticalCloseEdge, reach);
                if (currentReach !== undefined) {
                    onReachMove(currentReach, nextClientX, nextClientY, scale);
                }
            }
            if (currentReach === "x" || maskTouched) {
                updateState({ reach: "x" });
                return;
            }
            const toScale = (0, limitTarget_1.limitScale)(scale + ((currentTouchLength - touchLength) / 100 / 2) * scale, naturalWidth / width, variables_1.scaleBuffer);
            expose({ scale: toScale });
            updateState(Object.assign({ touchLength: currentTouchLength, reach: currentReach, scale: toScale }, (0, getPositionOnMoveOrScale_1.default)(x, y, width, height, scale, toScale, nextClientX, nextClientY, container, offsetX, offsetY)));
        }
    }, { maxWait: 8 });
    function updateRaf(position) {
        if (stopRaf || touched) {
            return false;
        }
        if (mounted.current) {
            updateState(Object.assign(Object.assign({}, position), { pause: visible }));
        }
        return mounted.current;
    }
    const slideToPosition = (0, useScrollPosition_1.default)((nextX) => updateRaf({ x: nextX }), (nextY) => updateRaf({ y: nextY }), (nextScale) => {
        if (mounted.current) {
            expose({ scale: nextScale });
            updateState({ scale: nextScale });
        }
        return !touched && mounted.current;
    }, container);
    const handlePhotoTap = (0, useContinuousTap_1.default)(onPhotoTap, (currentClientX, currentClientY) => {
        if (!reach) {
            const endScale = scale !== 1 ? 1 : Math.max(2, naturalWidth / width);
            onScale(endScale, currentClientX, currentClientY);
        }
    });
    function handleUp(nextClientX, nextClientY) {
        initialTouchRef.current = 0;
        if ((touched || maskTouched) && isActive) {
            updateState({
                touched: false,
                maskTouched: false,
                pause: false,
                stopRaf: false,
                reach: undefined,
            });
            const safeScale = (0, limitTarget_1.limitScale)(scale, naturalWidth / width);
            slideToPosition(x, y, lastX, lastY, width, height, scale, safeScale, lastScale, rotate, touchTime);
            onReachUp(nextClientX, nextClientY);
            if (CX === nextClientX && CY === nextClientY) {
                if (touched) {
                    handlePhotoTap(nextClientX, nextClientY);
                    return;
                }
                if (maskTouched) {
                    onMaskTap(nextClientX, nextClientY);
                }
            }
        }
    }
    (0, useEventListener_1.default)(isTouchDevice_1.default ? undefined : "mousemove", (e) => {
        e.preventDefault();
        handleMove(e.clientX, e.clientY);
    });
    (0, useEventListener_1.default)(isTouchDevice_1.default ? undefined : "mouseup", (e) => {
        handleUp(e.clientX, e.clientY);
    });
    (0, useEventListener_1.default)(isTouchDevice_1.default ? "touchmove" : undefined, (e) => {
        e.preventDefault();
        const position = (0, getMultipleTouchPosition_1.default)(e);
        handleMove(...position);
    }, { passive: false });
    (0, useEventListener_1.default)(isTouchDevice_1.default ? "touchend" : undefined, ({ changedTouches }) => {
        const touch = changedTouches[0];
        handleUp(touch.clientX, touch.clientY);
    }, { passive: false });
    (0, useEventListener_1.default)("resize", (0, useDebounceCallback_1.default)(() => {
        if (loaded && !touched) {
            updateState((0, getSuitableImageSize_1.default)(naturalWidth, naturalHeight, rotate, container));
            onPhotoResize();
        }
    }, { maxWait: 8 }));
    (0, useIsomorphicLayoutEffect_1.default)(() => {
        if (isActive) {
            expose(Object.assign({ scale, rotate }, fn));
        }
    }, [isActive]);
    function handlePhotoLoad(params) {
        updateState(Object.assign(Object.assign({}, params), (params.loaded &&
            (0, getSuitableImageSize_1.default)(params.naturalWidth || 0, params.naturalHeight || 0, rotate, container))));
    }
    function handleStart(currentClientX, currentClientY, currentTouchLength = 0) {
        updateState({
            touched: true,
            CX: currentClientX,
            CY: currentClientY,
            lastCX: currentClientX,
            lastCY: currentClientY,
            lastX: x,
            lastY: y,
            lastScale: scale,
            touchLength: currentTouchLength,
            touchTime: Date.now(),
        });
    }
    function handleWheel(e) {
        if (!reach) {
            const toScale = (0, limitTarget_1.limitScale)(scale - e.deltaY / 100 / 2, naturalWidth / width);
            updateState({ stopRaf: true });
            onScale(toScale, e.clientX, e.clientY);
        }
    }
    function handleMaskStart(e) {
        updateState({
            maskTouched: true,
            CX: e.clientX,
            CY: e.clientY,
            lastX: x,
            lastY: y,
        });
    }
    function handleTouchStart(e) {
        e.stopPropagation();
        handleStart(...(0, getMultipleTouchPosition_1.default)(e));
    }
    function handleMouseDown(e) {
        e.stopPropagation();
        if (e.button === 0) {
            handleStart(e.clientX, e.clientY, 0);
        }
    }
    const [translateX, translateY, currentWidth, currentHeight, currentScale, opacity, easingMode, FIT,] = (0, useAnimationPosition_1.default)(visible, originRef, loaded, x, y, width, height, scale, speed, (isPause) => updateState({ pause: isPause }), container);
    const transitionLayoutTime = easingMode < 4 ? speed / 2 : easingMode > 4 ? speed : 0;
    const transitionCSS = `transform ${speed}ms ${easing}`;
    const attrs = {
        className,
        onMouseDown: isTouchDevice_1.default ? undefined : handleMouseDown,
        onTouchStart: isTouchDevice_1.default ? handleTouchStart : undefined,
        onWheel: handleWheel,
        style: {
            width: currentWidth,
            height: currentHeight,
            opacity,
            objectFit: easingMode === 4 ? undefined : FIT,
            transform: rotate ? `rotate(${rotate}deg)` : undefined,
            transition: easingMode > 2 ? `${transitionCSS}, opacity ${speed}ms ease, height ${transitionLayoutTime}ms ${easing}` : undefined,
        },
    };
    return (react_1.default.createElement("div", { className: `PhotoView__PhotoWrap${wrapClassName ? ` ${wrapClassName}` : ""}`, style: style, onMouseDown: !isTouchDevice_1.default && isActive ? handleMaskStart : undefined, onTouchStart: isTouchDevice_1.default && isActive ? (e) => handleMaskStart(e.touches[0]) : undefined },
        react_1.default.createElement("div", { className: "PhotoView__PhotoBox", style: {
                transform: `matrix(${currentScale}, 0, 0, ${currentScale}, ${translateX}, ${translateY})`,
                transition: touched || pause ? undefined : transitionCSS,
                willChange: isActive ? "transform" : undefined,
            } }, src ? (react_1.default.createElement(Photo_1.default, Object.assign({ src: src, loaded: loaded, broken: broken }, attrs, { onPhotoLoad: handlePhotoLoad, loadingElement: loadingElement, brokenElement: brokenElement }))) : (render && render({ attrs, scale: currentScale, rotate })))));
}
exports.default = PhotoBox;
